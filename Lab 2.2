template <class T>
class IUVector
{
public:
	IUVector()
		: size_(0) {}

	explicit IUVector(size_t size)
	{
		size_ = size;
		vector_ = new T[size_];
	}

	IUVector(const IUVector <T>&copy)
		:size_(copy.size_)
	{
		vector_ = new T[size_];
		for (size_t i = 0; i < size_; i++)
			vector_[i] = copy.vector_[i];
	}

	IUVector(size_t size, const T massive)
		:size_(size)
	{
		vector_ = new T[size_];
		for (size_t i = 0; i < size_; i++)
			vector_[i] = massive[i];
	}

	size_t size()
	{
		return size_;
	}

	IUVector clear()
	{
		IUVector temp(*this);
		memcpy(temp, '\0', temp.size_);
		return temp;
	}

	T &operator [] (size_t index) const
	{
		return vector_[index];
	}

	IUVector &operator = (const IUVector <T>&vector)
	{
		if (&vector == this)
			return *this;
		delete[] vector_;
		size_ = vector.size_;
		vector_ = new T[size_];
		for (size_t i = 0; i < size_; i++)
			vector_[i] = vector.vector_[i];
		return *this;
	}

	IUVector operator * (T number)
	{
		IUVector temp(*this);
		for (size_t i = 0; i < size_; i++)
			temp.vector_[i] *= number;
		return temp;
	}

	IUVector &operator *= (T number)
	{
		*this = *this * number;
		return *this;
	}

	IUVector operator / (T number)
	{
		IUVector temp(*this);
		for (size_t i = 0; i < size_; i++)
			temp.vector_[i] /= number;
		return temp;
	}

	IUVector &operator /= (T number)
	{
		*this = *this / number;
		return *this;
	}

	~IUVector()
	{
		delete[] vector_;
	}

	template<class T> friend std::ostream &operator << (std::ostream &, IUVector <T>&);

private:
	T *vector_;
	size_t size_;
};

template <class T>
std::ostream &operator << (std::ostream &out, IUVector <T>&vector)
{
	out << "Vector: (";
	for (size_t i = 0; i < vector.size_; i++)
	{
		out << vector.vector_[i];
		if (i == vector.size_ - 1)
			out << ")" << std::endl;
		else
			out << ", ";
	}
	return out;
}
